/**** Configuration *****/
worldFilename('conf/world.txt'). /* Note: the world in the file must be a square/rectangle! */
:- dynamic worldWidth/1.
:- dynamic worldHeight/1.
:- dynamic worldCell/3. /* x, y and type */
:- dynamic worldAgent/2. /* identity and properties (position and health) of agents that joined the world */
line_of_sight(4).

/***** Main *****/
	  
:- dynamic started/1.
starting(this) :- not(started(this)).
startingI(X) :> main, assert(started(this)).

main :> use_module(library(random)),
		use_module('mas_modules/utils.txt'),
		use_module('mas_modules/world_objects.txt'),
		retrieveIdentity, /* action in utils */
	    nl, write('Started'), nl,
	    loadWorldFromFile.

/***** World loading *****/
	    
loadWorldFromFile :>
	nl, write('Loading world file...'), nl, 
	worldFilename(Filename), getFileLines(Filename, Lines), 
	eachFileLine(Lines, handleWorldLine),
	first(Lines, FirstLine), calculateWorldWidth(FirstLine), calculateWorldHeight(Lines),
	worldWidth(Width), worldHeight(Height),
	nl, write('World Width: '), write(Width), nl, write('World Height: '), write(Height), nl.

eachHandler(handleWorldLine, Line, Index) :- 
	name(Line, LineCharList), each(LineCharList, handler(handleWorldLineChar, Index)).
	
eachHandler(handler(handleWorldLineChar, LineIndex), Char, CharIndex) :-
	char_code(CharAtom, Char), /* converts back from the char code (a number) to the char atom (the string, eg. 'T') */
	saveWorldCell(CharIndex, LineIndex, CharAtom).

saveWorldCell(X, Y, Type) :- 
	assert(worldCell(X, Y, Type)),
	write('('), write(X), write(','), write(Y), write('): '), write(Type), nl.
    
/* Calculate and save the width of world, equal to the length of a world line (world is a rectangle). */
calculateWorldWidth(WorldLine) :- 
	name(WorldLine, WorldLineCharList),
	length(WorldLineCharList, Width),
	assert(worldWidth(Width)).
    
/* Calculate and save the height of world, equal to the number of world lines (world is a rectangle) minus the EOF. */
calculateWorldHeight(WorldLines) :- 
	length(WorldLines, Length), 
	Height is Length-1 /* for the EOF element */, 
	assert(worldHeight(Height)).
    
/***** end world loading *****/

receivedE(From, join) :> 
	nl, write('Received join request from '), write(From), nl,

	/* find available spawn point for the new agent */
	worldObject(AgentCellType, agent), worldCell(X, Y, AgentCellType), \+ worldAgent(AnotherAgent, position(X, Y)),
	assert(worldAgent(From, position(X, Y))),
	/* set health */
	assert(worldAgent(From, health(100))),
	
	write('Sending acceptance...'), nl,
	worldWidth(WorldWidth), worldHeight(WorldHeight),
	send(From, joined, [X, Y, WorldWidth, WorldHeight]).

/***** World sensing handling *****/

receivedE(From, sense) :> nl, write('Received sensing request from '), write(From),
						  write(', press enter to continue: '), nl, get_code(_),
						  worldAgent(From, position(FromX, FromY)),
						  write('Sending position...'), nl,
						  send(From, 'position', [FromX, FromY]),
						  line_of_sight(Span), calculateRect(FromX, FromY, Span, Top, Left, Width, Height),
						  write('Sending sensing information...'), nl,
						  sendRectCells(From, Top, Left, Width, Height),
						  send(From, 'senseEnd'). 
					
/* Calculate rect that spans for Span cells in the four directions starting from (X, Y) excluded. */	  
calculateRect(X, Y, Span, Top, Left, Width, Height) :- 
	calculateRectTop(Y, Span, Top), calculateRectLeft(X, Span, Left), 
	calculateRectHeight(Y, Top, Span, Height), calculateRectWidth(X, Left, Span, Width).
		
calculateRectTop(Y, Span, Top) :- TopCandidate is Y - Span, (TopCandidate < 0, Top is 0 ; Top is TopCandidate).
calculateRectLeft(X, Span, Left) :- LeftCandidate is X - Span, (LeftCandidate < 0, Left is 0 ; Left is LeftCandidate).
calculateRectHeight(Y, Top, Span, Height) :- 
	worldHeight(WorldHeight), TopSpan is Y-Top, (WorldHeight-Y < Span, BottomSpan is WorldHeight-Y ; BottomSpan is Span),
	Height is TopSpan + 1 + BottomSpan. /* +1 for the center */
calculateRectWidth(X, Left, Span, Width) :- 
	worldWidth(WorldWidth), LeftSpan is X-Left, (WorldWidth-X < Span, RightSpan is WorldWidth-X ; RightSpan is Span),
	Width is LeftSpan + 1 + RightSpan.

/* Iterate all the rect cells row by row, creating an InfoList with the format 
	[newRow,c11,c12,...,c1m,newRow,c21,c22,...c2m,newRow,...,newRow,cn1,cn2,...cnm]. 
   Note: not usable since there seem to be a limit on the length of the sendable list. */
createRectCellsInfo(Top, Left, Width, Height, ResultList) :> 
	/* start processing first row */
	createRectCellsInfo(Top, Left, Width, Height, [], ResultList, 0).
createRectCellsInfo(Top, Left, Width, Height, CurrentList, ResultList, Row) :> 
	Row = Height, ResultList=CurrentList. /* all rows processed, finished. */
createRectCellsInfo(Top, Left, Width, Height, CurrentList, ResultList, Row) :>
	/* new rect row: mark that in the list and start processing its columns. */
	append(CurrentList, [newRow], NewCurrentList),
	createRectCellsInfo(Top, Left, Width, Height, NewCurrentList, ResultList, Row, 0).
createRectCellsInfo(Top, Left, Width, Height, CurrentList, ResultList, Row, Column) :>
	/* all row columns processed, start processing next row */
	Column = Width, NextRow is Row+1, createRectCellsInfo(Top, Left, Width, Height, CurrentList, ResultList, NextRow).
createRectCellsInfo(Top, Left, Width, Height, CurrentList, ResultList, Row, Column) :>
	/* process rect cell: append its info to list */
	X is Left+Column, Y is Top+Row, worldCell(X, Y, Type),
	append(CurrentList, [X, Y, Type], NewCurrentList),
	NextColumn is Column+1, createRectCellsInfo(Top, Left, Width, Height, NewCurrentList, ResultList, Row, NextColumn).
    
/* Send world cells in rect to To */
sendRectCells(To, Top, Left, Width, Height) :- 
	forRange(0, Height, handler(sendRectRowCells, To, Top, Left, Width)).
forRangeHandler(handler(sendRectRowCells, To, Top, Left, Width), I) :-
	send(To, 'senseNewY'),
	forRange(0, Width, handler(sendRectCell, To, Top, Left, I)).
forRangeHandler(handler(sendRectCell, To, Top, Left, I), J) :-
	X is Left+J, Y is Top+I,
	worldCell(X, Y, Type), send(To, 'cell', [X, Y, Type]).
  
/***** end world sensing handling *****/

/***** Actions *****/

receivedE(From, move, FromX, FromY, ToX, ToY) :> 
	nl, write('Received move request from '), write(From), nl,
	moveObject(FromX, FromY, ToX, ToY),
	/* update agent position */
	retract(worldAgent(From, position(_, _))), assert(worldAgent(From, position(ToX, ToY))).
moveObject(FromX, FromY, ToX, ToY) :> 
	worldCell(FromX, FromY, FromCellType), 
	worldCell(ToX, ToY, ToCellType), 
	worldObject(ToCellType, ToObject),
	ToObject = blank,
	/* swap from and to */
	write('Moving object...'), nl,
	retract(worldCell(FromX, FromY, FromCellType)), assert(worldCell(FromX, FromY, ToCellType)),
	retract(worldCell(ToX, ToY, ToCellType)), assert(worldCell(ToX, ToY, FromCellType)).

receivedE(From, consume, X, Y) :> 
	nl, write('Received consume request from '), write(From), nl,
	consumeObject(X, Y).
consumeObject(X, Y) :>
	worldObject(BlankCellType, blank),
	write('Consuming object...'), nl,
	retract(worldCell(X, Y, CellType)), assert(worldCell(X, Y, BlankCellType)).
	
receivedE(From, attack, X, Y) :> 
	worldAgent(Agent, position(X, Y)),
	nl, write('agente '), write(From), write(' ha trovato '), write(Agent), nl,
	
		write(Agent), write('aspetta'), nl.
/***** end Actions *****/

