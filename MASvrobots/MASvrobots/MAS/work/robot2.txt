/***** Configuration *****/
:- dynamic time/1.
:- dynamic worldWidth/1.
:- dynamic worldHeight/1.
:- dynamic position/3. /* agent position: x, y and time. */
:- dynamic cell/4. /* x, y, type and time. */

/***** Main *****/

:- dynamic started/1.
starting(this) :- not(started(this)).
startingI(X) :> main, assert(started(this)).

main :> use_module(library(between)),
		use_module('mas_modules/utils.txt'),
		use_module('mas_modules/world_objects.txt'),
		retrieveIdentity, /* action in utils */
		assert(time(-1)),
	  	nl, write('Started'), nl,
	  	joinWorld.
	  	
/* Notify the world it want to join, obtaining in response info about the world, such as its width and height. */
joinWorld :> 
	nl, write('Joining world...'), nl,
	send(world, join).
receivedE(world, joined, SpawnX, SpawnY, WorldWidth, WorldHeight) :> 
	write('Joined!'), nl,
	write('Spawned at ('), write(SpawnX), write(', '), write(SpawnY), write(')'), nl,
	write('World has width = '), write(WorldWidth), write(' and height = '), write(WorldHeight), nl,
	assert(worldWidth(WorldWidth)), assert(worldHeight(WorldHeight)),
	newStep. /* Begin living! */
	  	
newStep :>
	time(CurrentTime), retractall(time(X)), NewTime is CurrentTime+1, assert(time(NewTime)),
	identity(Agent), nl, write(Agent), write(': begin new step, time '), write(NewTime), nl,
	nl, write('Sensing environment...'), nl,
	send(world, sense).
	
/***** Sense world *****/
	
receivedE(world, position, X, Y) :>
	nl, write('My position is ('), write(X), write(','), write(Y), write(')'), nl,
	time(Time), assert(position(X, Y, Time)).
	  	
receivedE(world, senseNewY) :> nl. /* Break line to print the next row aligned with the previous one */

receivedE(world, cell, X, Y, Type) :>
	write(Type),
	time(Time), assert(cell(X, Y, Type, Time)).
	
receivedE(world, senseEnd) :> 
	nl, nl, /* rows printing finished */
	act, /* Do something with the world */
	newStep. /* start next iteration */
	
/***** Act in world *****/

/* Attack adjacent enemy */
act :>
	time(TimeNow), position(MyX, MyY, TimeNow),
	closest(EnemyX, EnemyY, enemy),
	distance(EnemyX, EnemyY, MyX, MyY, Distance),
	Distance is 1, /* is adjacent */
	write('trovato ('), write(EnemyX), write(','), write(EnemyY), write(')'), nl,
	send(world, attack, [EnemyX, EnemyY]).
/* Move towards closest enemy to attack it */
act :>
	closest(EnemyX, EnemyY, enemy),
	write('Moving towards closest enemy at ('), write(EnemyX), write(','), write(EnemyY), write(')'), nl,
	moveTowards(EnemyX, EnemyY).

/* Explore closest unknown cell of the world. */
act :>
	closest(X, Y, void),
	write('Moving towards closest unknown cell at ('), write(X), write(','), write(Y), write(')'), nl,
	moveTowards(X, Y).
/* Default: do nothing */
act :>
	write('Nothing doable, waiting...'), nl.

/* Evaluates information about the cell at the latest time it has been seen. */
recallCell(X, Y, enemy) :- /* to recall cell where there is an enemy, i.e. an agent different from us. */
	time(TimeNow), position(MyX, MyY, TimeNow),
	worldObject(AgentCellType, agent),
	worldWidth(WorldWidth), worldHeight(WorldHeight), XUpper is WorldWidth-1, YUpper is WorldHeight-1,
	between(0, XUpper, X), between(0, YUpper, Y),
	recallCell(X, Y, AgentCellType), (X \= MyX ; Y \= MyY).
recallCell(X, Y, void) :- /* to recall unknown cell of the world */
	worldWidth(WorldWidth), worldHeight(WorldHeight), XUpper is WorldWidth-1, YUpper is WorldHeight-1,
	between(0, XUpper, X), between(0, YUpper, Y),
	voidCell(X, Y).
recallCell(X, Y, Type) :-
	cell(X, Y, Type, Time), \+ (cell(X, Y, _, OtherTime), OtherTime > Time).

/* a cell is void if never seen. */
voidCell(X, Y) :- \+ cell(X, Y, _, _).

/* Evaluates information about the closest cell. */
closest(X, Y, CellType) :-
	time(TimeNow), position(MyX, MyY, TimeNow),
	recallCell(X, Y, CellType), distance(X, Y, MyX, MyY, Distance),
	\+ (recallCell(OtherX, OtherY, CellType), distance(OtherX, OtherY, MyX, MyY, OtherDistance), OtherDistance < Distance).
	  	
/* Evaluates chessboard distance between two points. */
distance(FromX, FromY, ToX, ToY, Distance) :-
	Distance is max(abs(FromX-ToX), abs(FromY-ToY)). 
	  	
moveTowards(X, Y) :>
	time(TimeNow), position(MyX, MyY, TimeNow),
	XDistance is X-MyX, YDistance is Y-MyY,
	(XDistance > 0, XDelta is 1 ; XDistance = 0, XDelta is 0 ; XDistance < 0, XDelta is -1),
	(YDistance > 0, YDelta is 1 ; YDistance = 0, YDelta is 0 ; YDistance < 0, YDelta is -1),
	MyNewX is MyX+XDelta, MyNewY is MyY+YDelta,
	send(world, 'move', [MyX, MyY, MyNewX, MyNewY]).
	
/***** end act *****/

receivedE(world, dispose) :>
	write('My life ended, goodbye...'), nl,
	halt. /* close agent */
	  	
receivedE(From, Message) :> nl, write('Received '), write(Message), write(' from '), write(From), nl.

